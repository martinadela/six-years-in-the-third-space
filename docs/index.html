<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />

        <!-- page metadata -->
        <title>REPLACE_ME</title>
        <meta name="description" content="REPLACE_ME" />
        <meta property="og:image" content="REPLACE_ME" />
        <meta property="og:url" content="REPLACE_ME" />
        <meta property="og:title" content="REPLACE_ME" />
        <meta property="og:description" content="REPLACE_ME" />

        <meta name="twitter:card" content="summary_large_image" />

        <!-- favicons -->
        <!-- <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" /> -->
        <!--
            manifest.json provides metadata used when your web app is installed on a
            user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
        -->
        <!-- <link rel="manifest" href="%PUBLIC_URL%/manifest.json" /> -->


        <style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
    </head>
    <body>
		<script type="module">
            import * as THREE from 'https://unpkg.com/three@latest/build/three.module.js';
            import { GLTFLoader } from 'https://unpkg.com/three@latest/examples/jsm/loaders/GLTFLoader.js';
            import { OrbitControls } from 'https://unpkg.com/three@latest/examples/jsm/controls/OrbitControls.js'

            const degreesToRadians = function(angle) { return angle * math.pi / 180 }

            const pointsSpacedOnCircle = function(numPoints, radius, offsetAngle) {
                offsetAngle = offsetAngle || 0
                const incrementAngle = Math.PI * 2 / numPoints
                const points = []
                for (let i = 0; i < numPoints; i++) {
                    points.push({
                        x: radius * Math.cos(offsetAngle + incrementAngle * i),
                        y: radius * Math.sin(offsetAngle + incrementAngle * i),
                    })
                }
                return points
            }

            const sphericalSpacedOnSphere = function(numPoints, radius) {
                const sphericals = []
                const rowOrColumnCount = Math.pow(numPoints, 0.5)
                let rowCount = Math.ceil(rowOrColumnCount)
                let columnCount = (rowCount * Math.floor(rowOrColumnCount)) < numPoints ? Math.ceil(rowOrColumnCount) : Math.floor(rowOrColumnCount)
                for (let row = 0; row < rowCount; row++) {
                    for (let col = 0; col < columnCount; col++) {
                        const phi = row * (Math.PI / rowCount)
                        const theta = col * (2 * Math.PI / columnCount)
                        sphericals.push(new THREE.Spherical(radius, phi, theta))
                    }
                }
                console.log(sphericals.map(s => [s.theta / Math.PI, s.phi / Math.PI]))
                return sphericals
            }

            const sphericalToV3 = function(spherical) {
                const v3 = new THREE.Vector3()
                v3.setFromSpherical(spherical)
                return v3
            }

            const URL_ROOT = ''

            const LIGHT_AMBIENT_COLOR = 0xFFFFFF
            const LIGHT_AMBIENT_INTENSITY = 2

            const LIGHT_DIRECT_COLOR = 0xFFFFFF
            const LIGHT_DIRECT_INTENSITY = 2 * Math.PI

            const SCENE_BG_COLOR = 0xcccccc

            const CAMERA_FIELD_OF_VIEW_DEGREES = 75
            const CAMERA_NEAR = 0.1
            const CAMERA_FAR = 100
            const CAMERA_Z = 40

            const PLANET_RADIUS = 14
            const PLANET_COLOR = 0xaaaaaa
            const PLANETARY_ROTATION_AXIS_RANDOMNESS = Math.PI * 0
            const PLANETARY_ROTATION_RADIUS_RANDOMNESS = 0.5
            const PLANETARY_ROTATION_RADIUS = 17
            const PLANETARY_ROTATION_ANGLE_STEP = Math.PI / 2 * 0.005

            const SELF_ROTATION_INCREMENT = 0.001

			const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( CAMERA_FIELD_OF_VIEW_DEGREES, window.innerWidth / window.innerHeight, CAMERA_NEAR, CAMERA_FAR );
            const renderer = new THREE.WebGLRenderer({antialias: true});

            const controls = new OrbitControls( camera, renderer.domElement );

            scene.add(camera)

            const light1  = new THREE.AmbientLight(LIGHT_AMBIENT_COLOR, LIGHT_AMBIENT_INTENSITY);
            light1.name = 'ambient_light';
            camera.add( light1 );

            const light2  = new THREE.DirectionalLight(LIGHT_DIRECT_COLOR, LIGHT_DIRECT_INTENSITY);
            light2.position.set(0.5, 0, 0.866); // ~60ยบ
            light2.name = 'main_light';
            camera.add( light2 );

            renderer.physicallyCorrectLights = true;
            // Background color
            scene.background = new THREE.Color(SCENE_BG_COLOR)
            renderer.setPixelRatio( window.devicePixelRatio );

            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            // var geometry = new THREE.BoxGeometry();
            // var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            // var cube = new THREE.Mesh( geometry, material );
            // scene.add( cube );

            camera.position.z = CAMERA_Z;

            var loader = new GLTFLoader();

            function RotationAxis(spherical) {
                this.spherical = spherical
            }

            RotationAxis.prototype.show = function(scene) {
                const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
                const sphericalFurther = this.spherical.clone()
                sphericalFurther.radius += 200
                const points = [sphericalToV3(this.spherical), sphericalToV3(sphericalFurther)]
                
                var geometry = new THREE.BufferGeometry().setFromPoints( points );
                var line = new THREE.Line( geometry, material );
                scene.add(line)
            }

            RotationAxis.prototype.getV3 = function() {
                return sphericalToV3(this.spherical)
            }

            function Planet () {
                this.geometry = new THREE.SphereBufferGeometry( PLANET_RADIUS, 32, 32 )
                this.material = new THREE.MeshBasicMaterial( { color: PLANET_COLOR } )
                this.mesh = new THREE.Mesh( this.geometry, this.material )
            }

            Planet.prototype.show = function() {
                scene.add(this.mesh)
            }

            function Satellite (modelUrl) {
                this.modelUrl = modelUrl
                this.model = null

                this.planetaryRotationAxis = new THREE.Vector3( 1, 1, 1 )
                this.planetaryRotationAngleStep = PLANETARY_ROTATION_ANGLE_STEP
                this.planetaryRotationQuaternion = new THREE.Quaternion()
                this._updatePlanetaryRotation()
            }

            Satellite.prototype.load = function() {
                const self = this
                return new Promise(function (resolve, reject) {
                    loader.load(URL_ROOT + self.modelUrl, function ( gltf ) {
                        console.log('model loaded')
                        self.model = gltf
                        resolve(self)
                    }, undefined, function (error) {
                        console.error(error)
                        reject(error)
                    })
                })
            }

            Satellite.prototype.show = function() {
                scene.add(this.model.scene)
            }

            Satellite.prototype.planetaryRotationStep = function() {
                this.model.scene.position.applyQuaternion(this.planetaryRotationQuaternion)
            }

            Satellite.prototype.setPlanetaryRotationAxis = function(axis) {
                this.planetaryRotationAxis = axis
                this._updatePlanetaryRotation()
            }

            Satellite.prototype._updatePlanetaryRotation = function() {
                this.planetaryRotationQuaternion.setFromAxisAngle(this.planetaryRotationAxis, this.planetaryRotationAngleStep)
            }

            Satellite.prototype.getPosition = function() {
                return this.model.scene.position
            }

            Satellite.prototype.getPositionRadial = function() {
                const spherical = new THREE.Spherical()
                return spherical.setFromVector3(spherical)
            }

            Satellite.prototype.moveIncrement = function(delta) {
                this.model.scene.position.x += delta.x || 0
                this.model.scene.position.y += delta.y || 0
                this.model.scene.position.z += delta.z || 0
            }

            Satellite.prototype.moveIncrementRadial = function(delta) {
                const pointRadial = this.getPositionRadial()
                pointRadial.radius += delta.radius || 0
                pointRadial.angle = (pointRadial.angle + (delta.angle || 0)) % (Math.PI * 2)
                this.moveToRadial(pointRadial)
            }

            Satellite.prototype.moveToSpherical = function(sphericalPosition) {
                this.getPosition().setFromSpherical(sphericalPosition)
            }

            Satellite.prototype.rotateIncrement = function(delta) {
                this.model.scene.rotation.x += delta.x || 0
                this.model.scene.rotation.y += delta.y || 0
                this.model.scene.rotation.z += delta.z || 0
            }

            const satellites = [
                new Satellite('satellites/satellite2.glb'),
                new Satellite('satellites/satellite3.glb'),
                new Satellite('satellites/satellite4.glb'),
                new Satellite('satellites/satellite5.glb'),

                // new Satellite('satellites/satellite3.glb'),
                // new Satellite('satellites/satellite2.glb'),
                // new Satellite('satellites/satellite4.glb'),
                // new Satellite('satellites/satellite5.glb'),

                // new Satellite('satellites/satellite5.glb'),
                // new Satellite('satellites/satellite2.glb'),
                // new Satellite('satellites/satellite3.glb'),
                // new Satellite('satellites/satellite4.glb'),

                // new Satellite('satellites/satellite2.glb'),
                // new Satellite('satellites/satellite4.glb'),
                // new Satellite('satellites/satellite3.glb'),
            ]

            const planet = new Planet()

            Promise.all(satellites.map(function (satellite) {
                return satellite.load()
            })).then(function() {
                console.log('all models loaded')
                planet.show()
                const planetaryRotationAxes = sphericalSpacedOnSphere(satellites.length)
                    .map(function(spherical) {
                        // spherical.phi = (spherical.phi + Math.random() * PLANETARY_ROTATION_AXIS_RANDOMNESS) % (2 * Math.PI)
                        // spherical.theta = (spherical.theta + Math.random() * PLANETARY_ROTATION_AXIS_RANDOMNESS) % (2 * Math.PI)
                        return new RotationAxis(spherical)
                    })
                
                satellites.forEach(function(satellite, i) {
                    satellite.show()
                    const v3Axis = planetaryRotationAxes[i].getV3()
                    // planetaryRotationAxes[i].show(scene)

                    const sphericalPosition = new THREE.Spherical()
                    sphericalPosition.setFromVector3(v3Axis)

                    sphericalPosition.phi = (sphericalPosition.phi + Math.PI / 2) % (2 * Math.PI)
                    // sphericalPosition.theta = (sphericalPosition.theta + Math.PI / 2) % (2 * Math.PI)
                    sphericalPosition.radius = PLANETARY_ROTATION_RADIUS * (1 + Math.random() * PLANETARY_ROTATION_RADIUS_RANDOMNESS)

                    satellite.moveToSpherical(sphericalPosition)
                    satellite.setPlanetaryRotationAxis(v3Axis)
                })
                animate();
            })

            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                satellites.forEach(function(satellite, i) {
                    const rotateIncrement = SELF_ROTATION_INCREMENT + Math.random() * 0.005
                    satellite.rotateIncrement({
                        x: rotateIncrement,
                        y: rotateIncrement,
                    })
                    // satellite.moveIncrementRadial({
                    //     angle: Math.PI * 2 * 0.001
                    // })
                    satellite.planetaryRotationStep()
                })
                
                // console.log(models[0].scene.position.x)

                // cube.rotation.x += 0.01;
                // cube.rotation.y += 0.01;
                renderer.render( scene, camera );
            }


		</script>
    </body>
</html>
